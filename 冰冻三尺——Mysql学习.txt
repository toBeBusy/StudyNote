数据库设计三范式：
第一范式(1NF)：	
	如果关系模式R的每个关系r的属性都是不可分割的数据项，那么就称R是第一范式的模式。
	简单的说，满足第一范式的设计，每个属性都是原子项，不可分割。

第二范式(2NF)：
	如果关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么就称R是第二范式。
	简单的说，第二范式要满足以下的条件：首先要满足第一范式，其次每个非主属性要完全函数
依赖与候选键，或者是主键。也就是说，每个非主属性是由整个主函数决定的，而不能由主键的一
部分来决定。
	
第三范式(3NF):
	定义：如果关系模式R是2NF，且关系模式R(U,F)中的所有非主属性对任何候选关键字都不存在
传递依赖，则称关系R是属于第三范式。
	简单的说，就是不能依赖传递，即不能存在：非主键列A依赖于非主键列B，非主键列B依赖于
主键的情况。


	第二范式(2NF)和第三范式(3NF)的概念很容易混淆，区分它们的关键点在于，2NF非主键列是
否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖
于非主键列。


索引基础
	B-Tree索引
	B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，
取而代之的是从索引的根节点(图示并未画出)开始进行搜索。根节点的槽中存放了指向子节点的指针，
存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层
子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么
该记录不存在。

索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。
例：假设有如下数据表：
CREATE TABLE People(
	last_name  varchar(50)   not null,
	first_name varchar(50)   not null,
	dob 	   date			 not null,
	gender	   enum('m','f') not null,
	key(last_name, first_name, dob)
);
对于表中的每一行数据，索引中包含了last_name,first_name和dob列的值。
可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找

只适用于根据最左前缀的查找。上面所述的索引对如下类型的查询有效。
1.全值匹配
	全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen、
出生于1960-01-01的人。
2.匹配最左前缀(last_name)
	前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。
3.匹配列前缀
	也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。
这里也只使用了索引的第一列。
4.匹配范围值
	例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。
5.精确匹配某一列并范围匹配另外一列
	前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头的人。
6.只访问索引的查询
	B-Tree通常可以支持"只访问索引的查询"，即查询只需要访问索引，而无须访问数据行。

	除查询之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)。
	
B-Tree索引的限制：
	1.如果不是按照索引的最左列开始查找，则无法使用索引。
	2.不能跳过索引中的列。
	3.如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
	
典型优化：
	使用B-Tree存储URL，因为URL一般比较长，因此数据量大的时候，查询会变得缓慢。
	若删除原来URL列上的索引，而新增一个被索引的url_crc列，使用CRC32做哈希，就可以使用下面的
方式查询：
	原查询语句：SELECT id FROM url WHERE url='http://www.mysql.com';
	修改后的语句：SELECT id FROM url WHERE url='http://www.mysql.com' 
				  AND url_crc=CRC32('http://www.mysql.com');
	这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引
来完成查找。即使有多个记录有相同的索引值，查找仍然很快，只需要根据哈希值做快速的整数比较就能
找到索引条目，然后一一比较返回对应的行。
	可以使用触发器来维护哈希值，例：
	CREATE TABLE pseudohash(
		id int unsigned NOT NULL auto_increment,
		url varchar(255) NOT NULL,
		url_crc int unsigned NOT NULL DEFAULT 0,
		PRIMARY KEY(id);
	);
	
	创建触发器：
	CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN
	SET NEW.url_crc=CRC32(NEW.url);
	END;
	
	CREATE TRIGGER pseudohash_crc_ins BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN
	SET NEW.url_crc=CRC32(NEW.url);
	END;

高性能的索引使用策略：
	1.独立的列
	一些不恰当的查询会使MySQL无法使用已有的索引，如果查询中的列不是独立的列，则MySQL
就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。
	例：
		SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
	凭肉眼就能看出WHERE中的表达式其实等价于actor_id = 4，但是MySQL无法自动解析这个方程式。
	另一个常见的错误：
		SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
		
	2.前缀索引和索引选择性
	如果索引列的字符串很长，索引会变得大且慢。通常可以索引开始部分的字符，这样可以大大节约索引
空间，从而提高索引效率。但这样也会降低索引的选择性。对于BLOB、TEXT或者很长的VARCHAR类型的列，
必须使用前缀索引，因为MySQL不允许索引这些列完整的长度。
	创建索引的SQL:
		ALTER TABLE sakila.city_demo ADD KEY (city(7));
	
	3.多列索引
	很多人对多列索引的理解都不够，一个常见的错误就是，为每个列创建独立的索引，或者按照错误的
顺序创建多列索引。
	1)当出现服务器对多个索引做相交操作时(通常有多个AND条件)，通常意味着需要一个包含所有相关列的
多列索引，而不是多个独立的单列索引。
	2)当服务器需要对多个索引做联合操作时(通常有多个OR条件)，通常需要消耗大量的CPU和内存资源在算法
的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
	
	3.覆盖索引
	索引的叶子节点中已经包含要查询的数据，查询只需要扫描索引，无须回表。
	
重复索引：
	1.主键列和唯一列，不需要再创建索引，因为MySQL的主键限制和唯一限制都是通过索引来实现的。
	2.如果创建了索引(A,B),再创建索引(A)就是冗余索引。因为索引(A,B)也可以当作索引(A)来使用。
	
	
索引学习案例
	1.创建(sex,country)作为组合索引，虽然sex的选择性很低，但是可以通过在SQL语句中增加
AND SEX IN('m','f')来让MySQL选择该索引。这样写不会过滤任何行，和没有这个条件时返回的结果相同，
但是必须加上这个列的条件，MySQL才能够匹配索引的最左前缀。这个"诀窍"非常有效，但如果列有太多
不同的值，就会让IN()列表太长，这样做就不行了。
	可以通过IN()的技巧来避免同时需要(sex,country,age)和(sex,country,region,age)的索引。

	一些生僻的搜索条件(has_picture、eye_color、hair_color等)如何设计索引呢？这些列的选择性高、
使用也不频繁，可以选择忽略它们，让MySQL多扫描一些额外的行即可。另一个选择是在age列前面加上
这些列，在查询时使用前面提到过的IN()技术来处理搜索时没有指定这些列的场景。

	将age列放在最后面是因为age列多半是范围查询，between...and...语法不会触发MySQL的索引。
当然，也可以使用IN()来代替范围查询，例如改写条件为IN(18,19,20,21,22,23,24,25)，但不是所有的
范围查询都可以转换。多列索引的一项基本原则是，尽可能将需要做范围查询的列放到索引的后面，以便
优化器能使用尽可能多的索引列。

	IN()的技巧也不可以乱用，因为每额外增加一个IN()条件，优化器需要做的组合都将以指数的形式增加
最终可能会极大地降低查询性能。
	例：WHERE子句:
			WHERE eye_color   IN('brown','blue','hazel')
			AND	  hair_color  IN('black','red','blonde','brown')
			AND	  sex		  IN('M','F')
	对于该WHERE子句优化器会转化成4*3*2=24种组合，执行计划需要检查WHERE子句中所有的24种组合。
	
	2.避免多个范围条件
	假设我们有一个
	
	
	
	
	

	