数据库设计三范式：
第一范式(1NF)：	
	如果关系模式R的每个关系r的属性都是不可分割的数据项，那么就称R是第一范式的模式。
	简单的说，满足第一范式的设计，每个属性都是原子项，不可分割。

第二范式(2NF)：
	如果关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么就称R是第二范式。
	简单的说，第二范式要满足以下的条件：首先要满足第一范式，其次每个非主属性要完全函数
依赖与候选键，或者是主键。也就是说，每个非主属性是由整个主函数决定的，而不能由主键的一
部分来决定。
	
第三范式(3NF):
	定义：如果关系模式R是2NF，且关系模式R(U,F)中的所有非主属性对任何候选关键字都不存在
传递依赖，则称关系R是属于第三范式。
	简单的说，就是不能依赖传递，即不能存在：非主键列A依赖于非主键列B，非主键列B依赖于
主键的情况。


	第二范式(2NF)和第三范式(3NF)的概念很容易混淆，区分它们的关键点在于，2NF非主键列是
否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖
于非主键列。


索引基础
	B-Tree索引
	B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，
取而代之的是从索引的根节点(图示并未画出)开始进行搜索。根节点的槽中存放了指向子节点的指针，
存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层
子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么
该记录不存在。

索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。
例：假设有如下数据表：
CREATE TABLE People(
	last_name  varchar(50)   not null,
	first_name varchar(50)   not null,
	dob 	   date			 not null,
	gender	   enum('m','f') not null,
	key(last_name, first_name, dob)
);
对于表中的每一行数据，索引中包含了last_name,first_name和dob列的值。
可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找

只适用于根据最左前缀的查找。上面所述的索引对如下类型的查询有效。
1.全值匹配
	全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen、
出生于1960-01-01的人。
2.匹配最左前缀(last_name)
	前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。
3.匹配列前缀
	也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。
这里也只使用了索引的第一列。
4.匹配范围值
	例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人，这里也只使用了索引的第一列。
5.精确匹配某一列并范围匹配另外一列
	前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头的人。
6.只访问索引的查询
	B-Tree通常可以支持"只访问索引的查询"，即查询只需要访问索引，而无须访问数据行。

	除查询之外，索引还可以用于查询中的ORDER BY操作(按顺序查找)。
	
B-Tree索引的限制：
	1.如果不是按照索引的最左列开始查找，则无法使用索引。
	2.不能跳过索引中的列。
	3.如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
	
典型优化：
	使用B-Tree存储URL，因为URL一般比较长，因此数据量大的时候，查询会变得缓慢。
	若删除原来URL列上的索引，而新增一个被索引的url_crc列，使用CRC32做哈希，就可以使用下面的
方式查询：
	原查询语句：SELECT id FROM url WHERE url='http://www.mysql.com';
	修改后的语句：SELECT id FROM url WHERE url='http://www.mysql.com' 
				  AND url_crc=CRC32('http://www.mysql.com');
	这样做的性能会非常高，因为MySQL优化器会使用这个选择性很高而体积很小的基于url_crc列的索引
来完成查找。即使有多个记录有相同的索引值，查找仍然很快，只需要根据哈希值做快速的整数比较就能
找到索引条目，然后一一比较返回对应的行。
	可以使用触发器来维护哈希值，例：
	CREATE TABLE pseudohash(
		id int unsigned NOT NULL auto_increment,
		url varchar(255) NOT NULL,
		url_crc int unsigned NOT NULL DEFAULT 0,
		PRIMARY KEY(id);
	);
	
	创建触发器：
	CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN
	SET NEW.url_crc=CRC32(NEW.url);
	END;
	
	CREATE TRIGGER pseudohash_crc_ins BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN
	SET NEW.url_crc=CRC32(NEW.url);
	END;

高性能的索引使用策略：
	1.独立的列
	一些不恰当的查询会使MySQL无法使用已有的索引，如果查询中的列不是独立的列，则MySQL
就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。
	例：
		SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
	凭肉眼就能看出WHERE中的表达式其实等价于actor_id = 4，但是MySQL无法自动解析这个方程式。
	另一个常见的错误：
		SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
		
	2.前缀索引和索引选择性
	如果索引列的字符串很长，索引会变得大且慢。通常可以索引开始部分的字符，这样可以大大节约索引
空间，从而提高索引效率。但这样也会降低索引的选择性。对于BLOB、TEXT或者很长的VARCHAR类型的列，
必须使用前缀索引，因为MySQL不允许索引这些列完整的长度。
	创建索引的SQL:
		ALTER TABLE sakila.city_demo ADD KEY (city(7));
	
	3.多列索引
	很多人对多列索引的理解都不够，一个常见的错误就是，为每个列创建独立的索引，或者按照错误的
顺序创建多列索引。
	1)当出现服务器对多个索引做相交操作时(通常有多个AND条件)，通常意味着需要一个包含所有相关列的
多列索引，而不是多个独立的单列索引。
	2)当服务器需要对多个索引做联合操作时(通常有多个OR条件)，通常需要消耗大量的CPU和内存资源在算法
的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
	
	3.覆盖索引
	索引的叶子节点中已经包含要查询的数据，查询只需要扫描索引，无须回表。
	
重复索引：
	1.主键列和唯一列，不需要再创建索引，因为MySQL的主键限制和唯一限制都是通过索引来实现的。
	2.如果创建了索引(A,B),再创建索引(A)就是冗余索引。因为索引(A,B)也可以当作索引(A)来使用。
	
	
索引学习案例
	1.创建(sex,country)作为组合索引，虽然sex的选择性很低，但是可以通过在SQL语句中增加
AND SEX IN('m','f')来让MySQL选择该索引。这样写不会过滤任何行，和没有这个条件时返回的结果相同，
但是必须加上这个列的条件，MySQL才能够匹配索引的最左前缀。这个"诀窍"非常有效，但如果列有太多
不同的值，就会让IN()列表太长，这样做就不行了。
	可以通过IN()的技巧来避免同时需要(sex,country,age)和(sex,country,region,age)的索引。

	一些生僻的搜索条件(has_picture、eye_color、hair_color等)如何设计索引呢？这些列的选择性高、
使用也不频繁，可以选择忽略它们，让MySQL多扫描一些额外的行即可。另一个选择是在age列前面加上
这些列，在查询时使用前面提到过的IN()技术来处理搜索时没有指定这些列的场景。

	将age列放在最后面是因为age列多半是范围查询，between...and...语法不会触发MySQL的索引。
当然，也可以使用IN()来代替范围查询，例如改写条件为IN(18,19,20,21,22,23,24,25)，但不是所有的
范围查询都可以转换。多列索引的一项基本原则是，尽可能将需要做范围查询的列放到索引的后面，以便
优化器能使用尽可能多的索引列。

	IN()的技巧也不可以乱用，因为每额外增加一个IN()条件，优化器需要做的组合都将以指数的形式增加
最终可能会极大地降低查询性能。
	例：WHERE子句:
			WHERE eye_color   IN('brown','blue','hazel')
			AND	  hair_color  IN('black','red','blonde','brown')
			AND	  sex		  IN('M','F')
	对于该WHERE子句优化器会转化成4*3*2=24种组合，执行计划需要检查WHERE子句中所有的24种组合。

	！！！注：WHERE子句中条件的顺序不会影响Mysql索引的选择。


	2.避免多个范围条件
	对于范围条件查询(大于，小于，between等)，MySQL无法再使用范围列后面的其他索引列了。但是对于
“多个等值条件查询”则没有这个限制。
	
	EXPLAIN的type列的结果值从好到坏依次是：
	system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > 
index_subquery > range > index > ALL。一般来说，得保证查询至少达到range级别，最好能达到ref。
	
	
EXPLAIN中各个属性的含义：
	1.id
	select查询的序列号。
	2.select_type
	select查询的类型，主要是区别普通查询和关联查询，子查询之类的复杂查询。
	3.table
	输出的行所引用的表。
	4.type
	联合查询所使用的类型。
	type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是:
	system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery 
> index_subquery > range > index > ALL一般来说，得保证查询至少达到range级别，最好能达到ref。
	5.possible_keys
	指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性能，
可通过检验WHERE子句，看是否引用某些字段，或者检查字段是不是适合索引。
	6.key
	显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。
	7.key_len
	显示MySQL决定使用的键的长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得出一个多重主键
里MySQL实际使用了哪一部分。
	8.ref
	显示哪个字段或常数与key一起被使用。
	9.rows
	这个数表示MySQL要遍历多少数据才能找到，在innodb上是不准确的。
	10.Extra
	如果是Only index，这意味着检索只使用了索引树中的信息，这比扫描整个表要快。
	如果是where used，就是使用上了WHERE限制。
	如果是impossible where表示用不着where，一般就是没查出来啥。
	如果此信息显示Using filesort或者Using temporary的话会很吃力，where和order by的索引经常无法兼顾，
如果按照WHERE来确定索引，那么在ORDER BY时，就必然会引起Using filesort，这就要看是先过滤再排序划算，
还是先排序在过滤划算。
	
	
	
	
	
	
	
	
查询性能优化
	查询的生命周期：从客户端，到服务器，在服务器上进行解析，生成执行计划，执行，返回结果给客户端。
其中”执行“可以认为是最重要的阶段。这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据
处理，包括排序，分组等。
	查询性能低下的最基本原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式
进行优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：
	1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了
太多的列。
	2.确认MySQL服务器层是否在分析大量超过需要的数据行。
	
	简单的衡量查询开销的三个指标如下：
	1.响应时间
	2.扫描的行数
	3.返回的行数
	这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。
	
	1.响应时间
	响应时间分为服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务
器因为等待某些资源而没有真正执行查询的时间――可能是等I/O操作完成，也可能是等待行锁，等待。
	2.扫描的行数和返回的行数
	分析查询时，查看该查询扫描的行数是非常有帮助的，这在一定程度上能够说明该查询找到需要的数据的效率
高不高。理想情况下扫描的行数和返回的行数应该是相同的。但实际情况这种事并不多。
	3.扫描的行数和访问类型
	在EXPLAIN语句中的type列反应了访问类型，访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引
查询、常数引用等。这里列的这些，速度是从慢到快。扫描的行数也是从小到大。需要明白扫描表，扫描索引，范围
访问和单值访问的概念。


	一般MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：
	1.在索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的。
	2.使用索引覆盖扫描(在Extra列中出现了Using index)来返回记录，直接从索引中过滤不需要的记录并返回命中
的结果。这是在Mysql服务器层完成的，但无须再回表查询记录。
	3.从数据表中返回数据，然后过滤不满足条件的记录(在Extra列中出现Using Where)。这在MySQL服务器层完成，
MySQL需要先从数据表读出记录，然后过滤。

	如果发现查询需要扫描大量的数据，但只返回少数的行，那么可以尝试下面的方法去优化：
	1.使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。
	2.改变库表结构，例如使用单独的汇总表。
	3.重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。
	

重构查询的方式：
	在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果――――而不一定总是需要从MySQL
获取一模一样的结果集。有时候，可以将查询转换一种写法让其返回一样的结果，但是性能更好。但也可以通过修改
应用代码，用另一种方式完成查询，最终达到一样的目的。



查询缓存：
	在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。
这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓
存结果，这种情况下查询就会进入下一阶段的处理。
	如果当前的查询恰好命中了查询缓存，那么在返回查询结果之前MySQL会检查一次用户权限。这仍然是无须解析
查询SQL语句的，因为在查询缓存中已经存放了当前查询需要访问的表信息。如果权限没有问题，MySQL会跳过所有其他
阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。


查询优化处理：
	查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。
这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。这个过程中的任何错误都可能终止查询。
	语法解析器和预处理：
	首先，MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证
和解析查询。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否
能前后正确匹配。
	预处理器则根据一些MySQL规则进一步检查解析树是否合法，例如，这里将检查数据表和数据列是否存在，还会解析
名字和别名，看它们是否有歧义。下一步预处理器将验证权限。

	查询优化器：
	现在语法树认为是合法的了，并且优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的
结果。优化器的作用就是找到这其中最好的执行计划。
	MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。
最初，成本的最小单位是随机读取一个4K数据页的成本，后来(成本计算公式)变得更加复杂，并且引入了一些“因子”来估算
某些操作的代价，如当执行一次WHERE条件比较的成本。可以通过查询当前会话的Last_query_cost的值来得知MySQL计算的
当前查询的成本。
	MySQL的查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划。优化策略可以简单地
分为两种，一种是静态优化，一种是动态优化。静态优化可以直接对解析树进行分析，并完成优化。例如，优化器可以通过
一些简单的代数变换将WHERE条件转换成另一种等价形式。静态优化不依赖于特别的数值，如WHERE条件中带人的一些常数等。
静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化。可以认为这是一种“编译时优化”。







	




	