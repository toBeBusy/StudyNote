第4章	查询执行
查询编译分为三大步骤：
	1.分析：建立查询的分析树。
	2.查询重写：分析树被转化为初始查询计划，这种查询计划通常是查询的代数
表达式。然后初始查询计划被转化为一个预期所需执行时间较小的等价的计划。
	3.物理计划生成：通过第2步中抽象的查询计划，即通常所谓逻辑查询计划的每
一个操作符选择实现算法并选择这些操作符的执行顺序，逻辑计划被转化为物理查
询计划。与分析结果和逻辑计划一样，物理计划用表达式树来表示。物理计划还包
含许多细节，如被查询的关系是怎样被访问的，以及一个关系何时是否应当被排序。
	第2，3部分常被称作查询优化器，它们是查询编译的难点。
	
物理查询计划：
	物理查询计划由操作符构成，每个操作符实现计划中的一步。物理操作符常常
是一个关系代数操作符的特定的实现。
扫描表：
	定位关系R中元组的基本方法有两种：
	1.在很多情况下，关系R存放在二级存储器的某个区域中，它的元组排放在块
中。系统知道包含R的元组的块，并且可以一个接一个得到这些块。这个操作叫做
表扫描。
	2.如果R的任意一个属性上有索引，我们可以使用这个索引来得到R的所有元组
。这个操作叫做索引扫描。

物理操作符计算模型：
	一个查询通常包括几个关系代数操作，相应的物理查询计划由几个物理操作符
组成。既然明智地选择物理计划操作符是一个好的查询处理器所必不可少的，我们
必须能够估价我们使用的每个操作符的“代价”。我们将使用磁盘I/O的数目作为衡量
每个操作的代价的标准。

衡量代价的参数：
	有很多因素可以衡量一个操作符的代价，我们称之为衡量代价的参数。如果优
化器打算确定许多查询计划中的哪一个执行最快，那么估计代价是必需的。
	我们需要一个参数来表达操作符使用的内存大小，我们还需要其他参数来衡量
它的操作对象的大小。
	可能需要很多参数来衡量一个操作符的代价。这些参数中衡量关系中数据的多
少和分布的参数经常被定期地计算，以便帮助查询优化器选择物理操作符。
	有三类参数B、T和V：
	当描述一个关系R的大小时，绝大多数情况下，我们关心包含R的所有元组所需
的块的数目。这个块的数目表示为B(R)，如果我们知道指的是关系R，就可以仅仅
表示为B。通常，我们假设R是聚集的，即R存储在B个块中或近似的B个块中。
	有时候，我们也需要知道R中的元组的数目，我们将这个数量表示为T(R)，或在
我们知道所指关系为R时，简记为T。如果我们需要一个块中能容纳的R的元组数，
我们可以使用比例式T/B。
	最后，我们有时候希望参考出现在关系的一个列中的不同的值的数目。如果R
是一个关系，它的一个属性是a，那么V(R,a)是R中a对应列上不同值的数目。

扫描操作符的I/O代价：
	如果关系R是聚集的，那么表-扫描操作符的磁盘I/O数目近似为B。但是，如果
R不是聚集的，那么所需磁盘I/O数通常要高得多。如果R分布在其他关系的元组之
间，那么表-扫描所需读的块数可能与R的元组一样多，即I/O代价为T。
	如果我们不只想要R的一部分，我们通常能够避免查看整个索引和整个R。
	
物理操作符迭代器：
	许多物理操作可以实现为迭代器。迭代器是三个方法的集合，这三个方法允许
物理操作符结果的使用者一次一个元组地得到这个结果。这三个形成一个操作的迭
代器的方法是：
	1.Open()。这个方法启动获得元组的过程，但并不获得元组。它初始化执行操
作所需的任何数据结构并为操作的任何操作对象调用Open();
	2.GetNext()。这个方法返回结果中的下一个元组，并且对数据结构做必要的
调整以得到后续元组。在获取结果的下一元组时，它通常在操作对象上一次或更多
次地调用GetNext()。如果再也没有元组返回了，GetNext()将返回特殊值NotFound
这个值肯定不会与任何元组混淆。
	3.Close()。这个方法在所有的元组或使用者想得到的所有元组都获得后终结
迭代。它通常为操作符的每个操作对象调用Close()。

	一趟算法：
	我们怎样执行逻辑查询计划中的每个单独的步骤？每个操作符的算法的选择是
将逻辑查询计划转变成物理查询计划过程中的一个必不可少的部分。关于各种操作
符已提出了很多算法，它们大体上分为三类：
	1.基于排序的方法。
	2.基于散列的方法。
	3.基于索引的方法。
	另外，我们可以将操作符算法按照难度和代价分成三种“等级”：
	a)一些方法仅从磁盘读取一次数据，这就是一趟算法。
	b)一些方法处理的数据量太大以至于不能装入可利用的内存，但又不是可想象
的最大的数据集合。这些两趟算法的特点是首先从磁盘读一遍数据，用某种方式处
理，将全部或绝大部分写回磁盘，然后再第二趟中为了进一步处理，再读一遍数据
	c)某些方法对处理的数据量没有限制。这些方法用三趟或更多趟来完成工作，
它们是对两趟算法的自然的递归的推广。
	我们把操作符分为三大类：
	1.一次单个元组，一元操作。这类操作不需要一次在内存中装入整个关系，甚
至也不需要关系的大部分。这样，我们一次可以读一个块，使用内存缓冲区，并产
生我们的输出。
	2.整个关系，一元操作。这些单操作对象的操作需要一次从内存中看到所有或
大部分元组，因此，一趟算法局限于大小约为M或更小的关系。这里我们考虑的属于
这一类的操作是分组操作符和去重操作符。
	3.整个关系，二元操作。其他所有的操作可以归为这一类：并、交、差、连接
和积的集合形式以及包形式。我们将发现如果要用一趟算法，那么这类操作中的每
一个都要求至少一个操作对象的大小限制在M以内。
	
	
	




