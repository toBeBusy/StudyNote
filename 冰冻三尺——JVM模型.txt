1.jre路劲寻找方式：
	1.通过GetApplicationHome api来获得当前的Java.exe绝对路径：例：c:\j2sdk1.4.2_09\bin\Java.exe
	2.截取绝对路径c:\j2sdk1.4.2_09\并判断c:\j2sdk1.4.2_09\bin\Java.dll文件是否存在，如果存在则把c:\j2sdk1.4.2_09\作为jre路径。
	3.如果不存在则判断c:\j2sdk1.4.2_09\jre\bin\Java.dll是否存在，如果存在这c:\j2sdk1.4.2_09\jre作为jre路径。
	4.如果不存在调用GetPublicJREHome查HKEY_LOCAL_MACHINE\Software\JavaSoft\Java Runtime Environment\“当前JRE版本号”\JavaHome的路径为jre路径。


2.装载JVM.cfg：
	1.JVM.cfg文件JRE路径+\lib+\ARCH（CPU构架）+\JVM.cfgARCH（CPU构架）的判断是通过Java_md.c中GetArch函数判断的，该函数中windows平台只有两种情况：WIN64的‘ia64’，其他情况都为‘i386’。
	2.在我们的jdk目录中jre\bin\server和jre\bin\client都有JVM.dll文件存在，而Java正是通过JVM.cfg配置文
件来管理这些不同版本的JVM.dll的．
	3.获得JVM.dll的路径，JRE路径+\bin+\JVM类型字符串+\JVM.dll就是JVM的文件路径了，但是如果在调用Java
程序时用-XXaltJVM=参数指定的路径path,就直接用path+\JVM.dll文件做为JVM.dll的文件路径


3.装载JVM.dll：
	第2步已经找到了JVM的路径，Java通过LoadJavaVM来装入JVM.dll文件．装入工作很简单就是调用Windows API
函数：
	LoadLibrary装载JVM.dll动态连接库．然后把JVM.dll中的导出函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs挂接到InvocationFunctions变量的
	CreateJavaVM和GetDefaultJavaVMInitArgs函数指针变量上。JVM.dll的装载工作宣告完成。 


4.初始化JVM，获得本地调用接口


5.运行Java程序



GC基础：
	1.JAVA内存主要由Perm和Heap组成。
	2.Perm中主要存放JVM自己的反射对象，比如类对象和方法对象等。
	3.Heap又分为Old区和Yong区。Yong区又分为Eden和两个Survivor Spaces(from,to)。
Eden用来存放新生的对象。survivor用来存放Yong区中每次GC过后存活下来的对象。Old区主要存放应用程序中生命
周期长的内存对象。



垃圾回收描述：
	在Yong区中垃圾回收一般用Copying的算法，速度快。每次GC存活下来的对象首先由Eden拷贝到某个
SurvivorSpace，当SurvivorSpace空间满了后，剩下的live对象直接拷贝到Old区中去。因此，每次GC后，Eden
内存块会被清空。在Old区块中，垃圾回收一般用mark-compact的算法，速度慢些，但是减少内存要求。
	垃圾回收分多级，0级为全部回收，会回收Old段中的垃圾；1级或以上为部分垃圾回收，只会回收New中的垃圾，
内存溢出通常发生于Old段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 


当一个URL被访问时，内存申请的过程如下：
	A.JVM会试图为相关的JAVA对象在Eden中初始化一块内存区域
	B.当Eden空间足够时，内存申请结束。否则到下一步
	C.JVM试图释放在Eden中所有不活跃的对象(1级或更高级的垃圾回收)，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区
	D.Survivor区被用来作为Eden及Old区的中间交换区域，当Old区空间足够时，Survivor区的对象会被移到Old区，
否则会被保留在Survivor区
	E.当Old区空间不够时，JVM会在Old区进行完全的垃圾收集(0级)
	F.完全垃圾收集后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法再Eden区为新对
象创建内存区域，则出现“out of memory错误”。



年轻代:
   所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年
轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的
对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个
Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复
制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden
复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，
Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对
象在年轻代中的存在时间，减少被放到年老代的可能。

年老代:
    在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是
一些生命周期较长的对象。

持久代:
    用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者
调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。
持久代大小通过-XX:MaxPermSize=<N>进行设置。



Scavenge GC
    一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge 
GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个
区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden
区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能
尽快空闲出来。

Full GC
    对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC
要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有
如下原因可能导致Full GC：
    · 年老代（Tenured）被写满
    · 持久代（Perm）被写满 
    · System.gc()被显示调用 
    ·上一次GC之后Heap的各域分配策略动态变化


JVM内存区域划分
	JVM运行时数据区：Java栈，本地方法栈，堆(年轻代，老年代)，方法区，程序计数器。
	1.程序计数器
	程序计数器(Program Counter Register),也称作PC寄存器。它用来保存当前程序执行的指令的地址
(也可以说是保存下一条指令的所在存储单元的地址)，当CPU需要执行指令时，需要从程序寄出去中得到
当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数
器便自动加1或者根据转移指针得到下一条指令的地址，如此循环直至执行完所有的指令。
	由于JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中
的程序计数器是功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条
指令的。
	由于在JVM中，多线程是通过现场轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的
内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程
序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常
执行次序。因此，可以这么说，程序计数器是每个线程所私有的。
	在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的
地址；如果线程执行的是native方法，则程序计数器中的值是undefined。
	由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器
是不会发生内存溢出现象(OutOfMemory)的。

	2.Java栈
	Java栈也称作虚拟机栈(Java Vitual Machine Stack),也就是我们常常所说的栈，跟C语言的数据段中
的栈类似。事实上，Java栈是Java方法执行的内存模型。
	Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local
Variables),操作数栈(Operand Stack)，指向当前方法所属的类的运行时常量池的引用、方法返回地址和
一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当
方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必须位于Java栈的顶
部。讲到这里，大家就应该会明白为什么在使用递归方法的时候容易导致栈内存溢出的现象了以及为什么
栈区的空间不用程序员去管理了，这部分空间的分配和释放都是有系统自动实施的。对于所有的程序设计
语言来说，栈这部分空间对程序员来说是不透明的。
	局部变量表是用来存储方法中的局部变量(包括在方法中声明的非静态变量以及函数形参)。对于基本
数据类型的变量，则直接存储它的值；对于引用类型的变量，则存的是指向对象的引用。局部变量表的大
小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。
	操作数栈，用来存放操作数的栈。
	指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到来中的常量，所以必须要有一个
引用指向运行时常量。
	方法返回地址，当一个方法执行完毕之后，要返回之前调用它的方法，因此在栈帧中必须保存一个方
法返回的地址。
	由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的方法栈，互不干扰。

	3.本地方法栈
	本地方法栈和Java栈的作用和原来非常相似。只不过Java栈是为执行Java方法服务的，而本地方法栈
则是为执行本地方法服务的。在JVM规范中，并没有对本地方法的具体实现方法以及数据结构做强制规定，
虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

	4.堆
	Java中的堆是用来存储对象本身的以及数组(当然，数组的引用是存放在Java栈中的)。只不过和C语言
中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此
这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。

	5.方法区
	方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每
个类的信息(包括类的名称，方法信息，字段信息)、静态变量、常量以及编译器编译后的代码等。
	在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间
生成的字面量和符号引用。
	在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形
式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容
才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。


Java对象的内存布局
	对象在内存中存储的布局分为三块：
	1.对象头
	a.存储对象自身的运行时数据：Mark Work(在32bit和64bit虚拟机上长度分别为32bit和64bit)，包含
如下信息：
	  对象hashCode
	  对象GC分代年龄
	  锁状态标志（轻量级锁、重量级锁）
	  线程持有的锁（轻量级锁，重量级锁）
	  偏向锁相关：偏向锁、自旋锁、轻量级锁以及其他的一些锁优化策略是JDK1.6加入的，使得Synchronized
的性能与ReentrantLock的性能持平，在Synchronized可以满足要求的情况下，优先使用Synchronized，除非是
使用一些ReentrantLock独有的功能，例如指定时间等待等。
	b.类型指针：对象指向类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。
	2.实例数据：对象真正存储的有效信息。
	3.对齐填充：JVM要求对象的大小必须是8的整数倍，若不是，需要补位对齐。


如何判断对象是否可被回收：
	以"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到
GC Roots没有任何引用链相连时，则证明此对象是不可用的。
	在Java语言中，可作为GC Roots的对象包括下面几种：
	1.虚拟机栈(栈帧中的本地变量表)中引用的对象。
	2.方法区中类静态属性引用的对象。
	3.方法区中常量引用的对象。
	4.本地方法栈中JNI(即Native方法)引用的对象。