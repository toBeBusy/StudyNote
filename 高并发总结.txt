	1. select *** for update 实现悲观锁。
    
	2. 高并发情况下坚决不能用数据库的悲观锁。可以使用乐观锁
或者redis、zookeeper的分布式锁。
	
	3. 高并发的瓶颈：
	1)服务器网络带宽不够
	解决思路：增加网络带宽，DNS域名解析分发到多台服务器
	2)web线程链接数不够
	解决思路：增加服务器台数，设置负载均衡，前置代理服务器nginx等
	3)数据库链接查询上不去
	解决思路：数据库查询优化，读写分离、分表等
	
	4.高并发下需要处理的内容：
	1)尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，
可以大量减少与数据库的交互，提高性能。
	2)用jprofiler等工具找出性能瓶颈，减少额外开销。
	3)优化数据库查询语句。
	4)优化数据库结构，多做索引，提高查询效率。
	5)统计功能尽量做缓存，或按每天一统计或定时统计相关报表，避免
需要时进行统计的功能。
	6)能使用静态页面的地方尽量使用，减少容器的解析。
	7)使用服务器集群来解决单台的瓶颈问题。
	
	
	跨库join的几种解决思路
	1.全局表
	所谓的全局表，就是有可能系统中所有的模块都可能会依赖到的一些表。
比如数据字典。为了避免跨库join查询，我们可以将这类表在其他每个数据库
中均保存一份。同时，这类数据通常也很少发生修改，所以也不用太担心
“一致性”问题。
	2.字段冗余
	这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了避免
join查询。	
	3.系统层组装
	在系统层面，通过调用不同的模块组件或者服务，获取到数据并进行字段
拼装。简单而言就是先获取“主表”数据，然后再根据关联关系，调用其他模块
的组件或服务来获取依赖的其他字段。通常会通过缓存来避免RPC通信和数据库
查询的开销。

	
	浏览购买者订单是比较麻烦的，因为购买者订单信息和商品信息不是在同
一分表中。此时可以采取以下步骤：
	1.分页查找出购买者的订单列表。
	2.将订单信息返回给浏览器后，使用ajax获取每个订单的商品。
	使用ajax的好处是每个订单查询出数据之后就可以返回给浏览器显示，这样
用户体验会比较好。如果一次性查出来所有数据再返回给浏览器，会影响到用户
体验，让用户觉得很慢。
